# コンポーネント分離・作成ガイド

## コンポーネント命名規則

### 厳格なルール
1.  **ディレクトリ名**: kebab-case
2.  **TSXファイル名**: PascalCase
3.  **TSファイル名**: camelCase（ユーティリティ関数、ヘルパー、型など）
4.  **コンポーネント名**: PascalCase（ファイル名と完全一致）
5.  **ディレクトリとファイル名の対応**: kebab-caseからPascalCaseへの変換規則に従うこと。
6.  **バレルファイル禁止**: `index.ts`による集約エクスポートは行わず、必ず個別のファイルから直接インポートすること。
7.  **インポートパス**: `@/`エイリアスを使用し、相対パスは使用しないこと。

### 対応規則
- ディレクトリ名とTSXファイル名は、kebab-caseからPascalCaseへの変換規則において一致している必要がある。
- TSXファイル名と、その中で定義され���コンポーネント名は完全に一致させること。
- 上記の規則に合致しないコンポーネントを作成する場合は、新しいディレクトリを作成すること。

### 命名変換テーブル
ディレクトリ名（kebab-case）、TSXファイル名（PascalCase）、TSファイル名（camelCase）、コンポーネント名（PascalCase）は、それぞれ定められた命名規則に従う必要があります。例えば、`video-grid`というディレクトリには`VideoGrid.tsx`というコンポーネントファイルが配置され、その中のコンポーネント名は`VideoGrid`となります。

### インポートスタイル
コンポーネントをインポートする際は、必ずファイルパスを直接指定すること。`index.ts`（バレルファイル）からまとめてインポートする形式は禁止です。

### ディレクトリ構造ガイドライン
コンポーネントは、その役割に応じて`ui/`、`shared/`、`features/`のいずれかのディレクトリに配置します。`ui/`はshadcn/ui由来のコンポーネント、`shared/`は機能横断で再利用��れるコンポーネント、`features/`は特定の機能やページに固有のコンポーネントを格納します。

## Server/Client Components 使い分けルール

### 基本原則: Server Components優先
原則として、すべてのコンポーネントはServer Componentsとして作成し、インタラクティブ性やブラウザAPIへのアクセスなど、明確な理由がある場合にのみClient Componentsを使用します。

### 必須ルール
1.  **page.tsx は必ずServer Component**: ページのルートとなるコンポーネントは、必ずServer Componentとして実装します。
2.  **`'use client'` は最小限**: Client Componentsの使用は、本当に必要なコンポーネントに限定します。
3.  **データフェッチ優先度**: データフェッチは、可能な限りServer Componentsで行います。

### Server Components を使用する場合（デフォルト）
静的なコンテンツ表示、データベースやAPIからのデータ取得、SEOが重要なページ、初期表示速度が求められる場合、またはサーバー側の環境変数にアクセスする必要��ある場合は、Server Componentsを使用します。

### Client Components を使用する場合（必要時のみ）
`useState`や`useEffect`といったReactフックが必要な場合、`localStorage`などのブラウザAPIを使用する場合、`onClick`などのイベントハンドラを実装する場合、またはクライアントサイドでの実行が必須のサードパーティライブラリを使用する場合は、Client Componentsを選択します。

### 判断基準チェックリスト
コンポーネントを作成する際は、まずServer Componentとして実装可能か検討します。ReactフックやブラウザAPI、イベントハンドラが必要になった時点で、初めてClient Componentへの切り替えを検討してください。

### パフォーマンス最適化パターン
ページ全体をClient Componentにするのではなく、静的な部分はServer Componentとして残し、インタラクティブな機能を持つ部分のみを別のClient Componentとして切り出すことで、パフォーマンスを最適化します。

## コンポーネント分離ガイドライン

### 核心原則: 動作の観察可能性
コンポーネントを分離するかの判断は、コードの行数ではなく、「その動作がテスト可能か」を基準に行います。テストを書くためにコンポーネントの責務を明確にする必要がある場合、それが分離のサインです。

### 分離しない場合
コンポーネントの表示内容が、受け取ったpropsの値によって単純に切り替わるだけであれば、分離は不要です。このようなコンポーネントは、Storybookで異なるpropsを与えたストーリーを作成することで、各表示パターンを十分にテストできます。

### 分離する場合
propsから受け取った値を基に、何らかの計算や複雑な条件判定を行い、その結果によって表示を切り替える場合は、分離を検討します。計算ロジックをコンポーネントから抽出し、純粋な関数としてテスト可能にすることが推奨されます。コンポーネント自体は、その計算結果をpropsとして受け取り、表示に専念するようにします。

## 高度なパターン: 内部可視性制御
親コンポーネント側で条件分岐を用いてコンポーネントの表示・非表示を切り替えるのではなく、常にコンポーネントをレンダリングし、`isVisible`のようなpropsを渡してコンポーネント内部で表示を制御します。この方法により、親の持つ状態（フックなど）をモックすることなく、コンポーネントを単体でテストしやすくなります。

## 高度なパターン: 完全ロジック抽出
外部の状態（フックやprops）に依存する複雑な分岐ロジックは、条件判定部分だけでなく、分岐後の処理全体をコンポーネントから別の関数として抽出します。コンポーネントは、その抽出された関数を呼び出すだけのシンプルな役割に徹することで、テストが容易になり、責務が明確になります。

## Package by Feature アーキテクチャ
関連するコードは、技術的な分類（例: `hooks`, `utils`）ではなく、機能的なまとまりでグループ化します。機能固有のロジック、フック、型定義などは、���れらを使用するコンポーネントの近くに配置（コロケーション）することで、コードの凝集度を高め、保守性を向上させます。真に汎用的で、複数の機能から利用されるものだけを、`src/lib`や`src/hooks`といったグローバルな場所に配置します。

## 決定フレームワーク
コンポーネントを分離するかどうかは、以下の点を考慮して決定します。
- その動作はpropsで制御できるか？
- 外部の条件によってレンダリングが左右されるか？
- 外部の状態に依存した複雑なロジックを含んでいるか？
- レンダリング前に計算処理が必要か？
- その部分だけで意味のあるテストが書けるか？
- 明確で単一の責任を持っているか？

適切な分離は、テスト可能性、再利用性、保守性を高め、Storybookによるドキュメント化を容易にします。

## コンポーネント作成チェックリスト
コンポーネントを作成する際は、配置場所、命名規則、インポートパスのエイリアス使用、バレルファイルの不使用、`Package by Feature`の原則、Server/Client Componentsの適切な選択など、本ガイドラインに定められたすべてのルールを遵守してください。また、`role`のようなHTMLのARIA属性と競合するprop名は避けてください。

## AIエージェント向け重要な注意事項
コンポーネントの作成やリファクタリングを行う前には、必ずユーザーの承認を得てください。その際、適用する命名規則や正確なファイルパスを含んだ、明確な計画を提示することが求められます。
